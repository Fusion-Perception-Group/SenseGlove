import argparse
from pathlib import Path

TEMPLATE = """
// Generated by scripts/embed_file.py
// DO NOT EDIT
#ifndef __FILE_{name_upper}_H__
#define __FILE_{name_upper}_H__

#include <stdint.h>

struct file_{name} {
    static constexpr const char* name = "{name}";
    static constexpr const std::size_t size;
    static constexpr const std::uint8_t data[] = [
{data}
        ];
};

#endif // __FILE_{name_upper}_H__
"""

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("file", help="File file")
    parser.add_argument("-n", "--name", help="File name", default=None)
    parser.add_argument("-o", "--output", help="Output file", default=None)
    parser.add_argument("-f", "--force", help="Force overwrite", action="store_true")

    args = parser.parse_args()
    path = Path(args.File)
    if not path.exists():
        print(f"File {path} does not exist")
        return
    if not path.is_file():
        print(f"File {path} is not a file")
        return
    
    pio_dir = Path(__file__).parent.parent
    
    name = args.name or path.stem
    name_upper = name.upper()
    output = args.output or pio_dir/"lib"/"Shared"/f"file_{name}.hpp"
    output_path = Path(output)
    if output_path.exists() and not args.force:
        print(f"Output file {output_path} already exists")
        return
    with open(path, "rb") as f:
        data = f.read()
        data = ",\n".join([f"            0x{b:02x}" for b in data])
    with open(output_path, "w") as f:
        f.write(TEMPLATE.format(name=name, name_upper=name_upper, data=data))
        f.truncate()
    print(f"Generated File {name} in {output}")
